<!DOCTYPE html> 
<html lang='en-US' xml:lang='en-US'> 
<head> <title>Arithmetic coding</title> 
<meta charset='utf-8' /> 
<meta content='TeX4ht (https://tug.org/tex4ht/)' name='generator' /> 
<meta content='width=device-width,initial-scale=1' name='viewport' /> 
<link href='index.css' rel='stylesheet' type='text/css' /> 
<meta content='index.tex' name='src' /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script async='async' id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js' type='text/javascript'></script>  
</head><body>
   <div class='maketitle'>
                                                                  

                                                                  
                                                                  

                                                                  

<h2 class='titleHead'>Arithmetic coding</h2>
 <div class='author'><span class='ecrm-1200'>Vicente González Ruiz</span></div><br />
<div class='date'><span class='ecrm-1200'>December 8, 2022</span></div>
   </div>
   <h3 class='likesectionHead' id='contents'><a id='x1-1000'></a>Contents</h3>
   <div class='tableofcontents'>
    <span class='sectionToc'>1 <a href='#basics' id='QQ2-1-2'>Basics</a></span>
<br />    <span class='sectionToc'>2 <a href='#an-ideal-encoder' id='QQ2-1-3'>An ideal encoder</a></span>
<br />     <span class='subsectionToc'>2.1 <a href='#example' id='QQ2-1-4'>Example</a></span>
<br />    <span class='sectionToc'>3 <a href='#an-ideal-decoder' id='QQ2-1-5'>An ideal decoder</a></span>
<br />    <span class='sectionToc'>4 <a href='#incremental-transmission' id='QQ2-1-6'>Incremental transmission</a></span>
<br />    <span class='sectionToc'><a href='#references'>References</a></span>
   </div>
<!-- l. 6 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='basics'><span class='titlemark'>1   </span> <a id='x1-20001'></a>Basics</h3>
     <ul class='itemize1'>
     <li class='itemize'>Arithmetic coding <span class='cite'>[<a href='#Xrissanen1979arithmetic'>1</a>, <a href='#Xwitten1987arithmetic'>2</a>]</span>relaxes the Eq. (Eq:Huffman), verifying that, for every
     encoded symbol, \begin {equation}  l\big (c(s)\big ) = I(s), \tag {Eq:arithmetic}  \end {equation}
     i.e. the number of bits of data (code-word) assigned by the encoder is equal to
     the number of bits of information that the symbol represent.</li></ul>
<!-- l. 19 --><p class='noindent'><div style='text-align:center;'> <img src='graphics/comparacion.svg' /> </div> 
</p>
                                                                  

                                                                  
     <ul class='itemize1'>
     <li class='itemize'>It can be said that, arithmetic coding is optimal because the average length
     of an arithmetic code is equal to the entropy of the information source,
     measured in bits/symbol.</li></ul>
<!-- l. 28 --><p class='noindent'><div style='text-align:center;'> <img src='graphics/aritmetica_ejemplo.svg' /> </div> 
</p><!-- l. 30 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='an-ideal-encoder'><span class='titlemark'>2   </span> <a id='x1-30002'></a>An ideal encoder</h3>
<!-- l. 31 --><p class='noindent'>
     </p><ol class='enumerate1'>
<li class='enumerate' id='x1-3002x1'>Let \([L,H)\leftarrow [0.0,1.0)\) an interval of real numbers.
     </li>
<li class='enumerate' id='x1-3004x2'>
     <!-- l. 37 --><p class='noindent'>While the input is not exhausted:
         </p><ol class='enumerate2'>
<li class='enumerate' id='x1-3006x1'>Split  \([L,H)\)  into  so  many  sub-intervals  as  different  symbols  are  in  the
         alphabet.  The  size  of  each  sub-interval  is  proportional  to  the
         probability of the corresponding symbol.
         </li>
<li class='enumerate' id='x1-3008x2'>Select the sub-interval \([L',H')\) associated with the encoded symbol.
         </li>
<li class='enumerate' id='x1-3010x3'>\([L,H)\leftarrow [L',H')\).</li></ol>
     </li>
<li class='enumerate' id='x1-3012x3'>Output a real number \(x\in [L,H)\) (the arithmetic code-stream). The number of decimals
     of \(x\) should be large enough to distinguish the final sub-interval \([L,H)\) from the rest of
     possibilities.</li></ol>
                                                                  

                                                                  
<!-- l. 57 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='example'><span class='titlemark'>2.1   </span> <a id='x1-40002.1'></a>Example</h4>
     <ul class='itemize1'>
     <li class='itemize'>Imagine a binary sequence, where \(p(\text {A})=3/4\) and \(p(\text {B})=1/4\). Compute the arithmetic code of
     the sequences A, B, AA, AB, BA y BB.</li></ul>
<!-- l. 66 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='an-ideal-decoder'><span class='titlemark'>3   </span> <a id='x1-50003'></a>An ideal decoder</h3>
<!-- l. 67 --><p class='noindent'>
     </p><ol class='enumerate1'>
<li class='enumerate' id='x1-5002x1'>Let \([L,H)\leftarrow [0.0,1.0)\) the initial interval.
     </li>
<li class='enumerate' id='x1-5004x2'>
     <!-- l. 73 --><p class='noindent'>While the input is not exhausted:
         </p><ol class='enumerate2'>
<li class='enumerate' id='x1-5006x1'>Split  \([L,H)\)  in  so  many  sub-intervals  as  different  symbols  are  in  the
         alphabet.  The  size  of  each  sub-interval  is  proportional  to  the
         probability of the corresponding symbol.
         </li>
<li class='enumerate' id='x1-5008x2'>
         <!-- l. 82 --><p class='noindent'>Input so many bits of \(x\) as they are needed to:
         </p><!-- l. 84 --><p class='noindent'>
             </p><ol class='enumerate3'>
<li class='enumerate' id='x1-5010x1'>Select the sub-interval \([L',H')\) that contains \(x\).
             </li>
<li class='enumerate' id='x1-5012x2'>Output the symbol that \([L',H')\) represents.
             </li>
                                                                  

                                                                  
<li class='enumerate' id='x1-5014x3'>\([L,H)\leftarrow [L',H')\).</li></ol>
         </li></ol>
     </li></ol>
<!-- l. 97 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='incremental-transmission'><span class='titlemark'>4   </span> <a id='x1-60004'></a>Incremental transmission</h3>
     <ul class='itemize1'>
     <li class='itemize'>
     <!-- l. 100 --><p class='noindent'>It is not necessary to wait for the end of the encoding to generate the
     arithmetic code. When we work with binary representations of the real
     numbers  \(L\)  and  \(H\),  their  most  significant  bits  become  identical  when  the
     interval  is  reduced.  These  bits  belong  to  the  output  arithmetic  code,
     therefore, they can be output as soon as they match.
     </p><!-- l. 107 --><p class='noindent'>For example, when the symbol B is encoded, a code-bit 1 can be output
     because any sequence of symbols that start with B have a code-word that
     begins with 1.
     </p></li>
     <li class='itemize'>
     <!-- l. 111 --><p class='noindent'>When the most significant bits of \(L\) and \(H\) are output, the bits of each register
     are shifted to the left, and new bits need to be inserted. The results is an
     automatic zoom of the selected sub-interval.
     </p><!-- l. 116 --><p class='noindent'>Following with the previous example, the register shifting generates an
     ampliation of the \([0.50,1.00)\) interval to the \([0.00,1.00)\).</p></li></ul>
   <div class='thebibliography'>
   <p class='bibitem'><span class='biblabel'>
 [1]<span class='bibsp'>   </span></span><a id='Xrissanen1979arithmetic'></a>Jorma Rissanen and Glen G. Langdon. <a href='https://scholar.google.es/scholar?hl=es&amp;as_sdt=0%2C5&amp;q=+Rissanen+Langdon+Arithmetic+Coding+1979&amp;btnG='>Arithmetic coding</a>. <span class='ecti-1000'>IBM Journal
   </span><span class='ecti-1000'>of research and development</span>, 23(2):149–162, 1979.
   </p>
   <p class='bibitem'><span class='biblabel'>
 [2]<span class='bibsp'>   </span></span><a id='Xwitten1987arithmetic'></a>Ian H Witten, Radford M Neal, and John G Cleary. <a href='https://scholar.google.es/scholar?hl=es&amp;as_sdt=0%2C5&amp;q=Witten+Neal+Cleary+Arithmetic+Coding+for+Data+Compression&amp;btnG='>Arithmetic coding
   for data compression</a>. <span class='ecti-1000'>Communications of the ACM</span>, 30(6):520–540, 1987.
</p>
   </div>
<p id='references'><a id='Q1-1-7'></a>
    
</p></body> 
</html>